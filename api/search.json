[{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"CS100 Recitation 2GKxx\n\nContents\n算术类型（续）\n运算符和表达式（续）\n控制流\n变量命名、声明、初始化\n名字查找\n\n\n算术类型\n字面值 (literals)像 42 这样把值写在脸上的就是字面值。\n\n整型字面值 (integer literals)：42, 100L, 0ll, 405ul\n不写后缀，默认是 int，如果 int 不够大就是 long，还不够大就是 long long。还不够大的话：\n如果编译器支持 __int128 并且它够大，那就是 __int128\n否则报错 (ill-formed)。\n\n\n不存在负字面值：-42 是将一元负号 - 作用在字面值 42 上形成的表达式。\n后缀有 u (unsigned), l (long), ll (long long)。大小写不敏感，但是不可以是 lL 或 Ll。\n后缀可以任意组合。\n\n\n\n\n字面值 (literals)像 42 这样把值写在脸上的就是字面值。\n\n整型字面值 (integer literal)：42, 100L, 0ll, 405ul\n还可以有十六进制字面值：0xBAADF00D\n以及八进制字面值：052\n以及 C23 的二进制字面值：0b101010\n实际上编译器早就支持了，隔壁 C++14 就有二进制字面值了。\n\n\n这里所有的字母的大小写都随意。\n\n\n\n\n字面值 (literals)浮点数字面值：3.14, 3.14f, 3.14l, 1e8, 3e-8\n\n不写后缀，默认是 double。f 是 float，l 是 long double，大小写不敏感。\n1e8 表示 $10^8$，但它是 double 而非整数。\n\n字符字面值：&#39;a&#39;\n\n猜猜 &#39;a&#39; 是什么类型？\n\n\n字面值 (literals)浮点数字面值：3.14, 3.14f, 3.14l, 1e8, 3e-8\n\n不写后缀，默认是 double。f 是 float，l 是 long double，大小写不敏感。\n1e8 表示 $10^8$，但它是 double 而非整数。\n\n字符字面值 (character literal)：&#39;a&#39;\n\n&#39;a&#39; 的类型居然是 int？？\nC++ 里它就是 char 了。\n\n\n字符？一个小整数罢了char c = &#39;a&#39;;\nc 所存储的内容就是整数 97，即 &#39;a&#39; 的 ASCII 码，而非任何神秘的图像。\n假如字符 c 是一个数字字符，如何获得它所表示的数值？\n\n字符？一个小整数罢了char c = &#39;a&#39;;\nc 所存储的内容就是整数 97，即 &#39;a&#39; 的 ASCII 码，而非任何神秘的图像。\n假如字符 c 是一个数字字符，c - &#39;0&#39; 就是它所表示的数值。\n练习：实现一个函数 is_lower，接受一个 char，判断它是不是小写英文字母。\n\n字符？一个小整数罢了练习：实现一个函数 is_lower，接受一个 char，判断它是不是小写英文字母。\nbool is_lower(char c) &#123;\n  return c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;;\n&#125;\n\n练习：实现一个函数 to_upper，接受一个 char，如果它是小写英文字母就返回它的大写形式，否则返回它本身。\n\n字符：一个小整数罢了练习：实现一个函数 to_upper，接受一个 char，如果它是小写英文字母就返回它的大写形式，否则返回它本身。\nchar to_upper(char c) &#123;\n  return is_lower(c) ? c - 32 : c;\n&#125;\n\n条件运算符：condition ? exprT : exprF\n先对 condition 求值，如果为 true 则执行 exprT，否则执行 exprF\n为数不多的能确定运算对象求值顺序的运算符之一\n\n字符：一个小整数罢了更直白一些：\nchar to_upper(char c) &#123;\n  return is_lower(c) ? c - (&#x27;a&#x27; - &#x27;A&#x27;) : c;\n&#125;\n\nself-documenting code：你的代码自己能解释自己。\n\nc - 32 虽然简洁，但出现了一个“幻数” (magic number)：32是什么意思？\nc - (&#39;a&#39; - &#39;A&#39;) 一定会被编译器优化为 c - 32，完全不必担心。\n\n\n字面值 (literals)字符串字面值：&quot;hello&quot;\n\n它的类型是 char [N+1]，其中 N 是这个字符串的长度。\n**但在 C++ 中它是 const char [N+1]**，而且事实上它确实不可修改！\nchar *str = &quot;hello&quot;; // Correct C, Incorrect C++.\nstr[0] = &#x27;b&#x27;;        // Undefined behavior. (Forbidden in C++)\n正确的办法：\nconst char *str = &quot;hello&quot;;\nchar arr[] = &quot;hello&quot;;\n\n\n\n\n溢出一个变量的值超出了这个变量所能表示的范围。\n\n这里的“变量”有可能是临时量！\n\n判断下列运算是否溢出：\nint ival = 10000000;\nlong long llval = ival * ival;\nlong long llval2 = 1ll * ival * ival;\nlong long llval3 = 0ll + ival * ival;\n\n\n溢出一个变量的值超出了这个变量所能表示的范围。\n\n这里的“变量”有可能是临时量！\n\n判断下列运算是否溢出：\nint ival = 10000000;\nlong long llval = ival * ival;         // 溢出\nlong long llval2 = 1ll * ival * ival;  // ok\nlong long llval3 = 0ll + ival * ival;  // 溢出\n\n\n溢出\n无符号数永远不会溢出：无符号数的运算总是在 $\\bmod 2^N$ 意义下进行的，其中 $N$ 是这个无符号数的位数。\nunsigned uval = -1; 执行后，uval 的值是多少？\n\n\n带符号整数溢出是 undefined behavior：你无法对结果作任何假定。\n可能会得到在 2’s complement 意义下的一个值，也可能被视为 runtime-error 而崩溃，或者其它任何可能的结果。\n\n编译器可以假定你的程序没有 undefined behavior。\n\n\n\n\n\n\n\n\n\n不开 O2 能过，开了 O2 却 RE？\n\n\n\n\n\n运算符和表达式\n递增、递减运算符++i, i++, --i, i--\n\n效果是给 i 的值加 1 或减 1。\n\n试一试：\nint ival = 42;\nprintf(&quot;%d\\n&quot;, ival++);\nprintf(&quot;%d\\n&quot;, ++ival);\nprintf(&quot;%d, %d\\n&quot;, ++ival, ival++);\n\n\n递增、递减运算符int ival = 42;\nprintf(&quot;%d\\n&quot;, ival++);              // 42, 此时 ival == 43\nprintf(&quot;%d\\n&quot;, ++ival);              // 44, 此时 ival == 44\nprintf(&quot;%d, %d\\n&quot;, ++ival, ival++);\n// warning: operation on ‘ival’ may be undefined [-Wsequence-point]\n\n\n没人规定函数的各个参数一定从左向右求值：order of evaluation\nf(A, B) 中，A 和 B 谁先求值是 unspecified。\n如果 A 和 B 都修改了某一个变量，或者一个读、一个写，则是 undefined behavior。\n\n\n递增、递减运算符int ival = 42;\nprintf(&quot;%d\\n&quot;, ival++);              // 42, 此时 ival == 43\nprintf(&quot;%d\\n&quot;, ++ival);              // 44, 此时 ival == 44\n\n\n++ival 将 ival 的值加 1，并返回递增后的值。\nival++ 将 ival 的值加 1，但返回其递增前的值。\n递减类似。\n\n\n关系运算符&lt;, &lt;=, &gt;, &gt;=, ==, !=\n返回值类型是 int，1 表示 true，0 表示 false。\n\na &lt; b &lt; c 是在做什么？\n\n\n关系运算符&lt;, &lt;=, &gt;, &gt;=, ==, !=\n返回值类型是 int，1 表示 true，0 表示 false。\n\na &lt; b &lt; c 是在做什么？\n左结合：a &lt; b &lt; c 被视为 (a &lt; b) &lt; c\n实际上比较的是 c 和 1 或 0 的大小关系\n\n\n\n\n逻辑运算符&amp;&amp;, ||, !\n短路求值 (short-circuited)：先求左边，如果左边的结果能确定表达式的结果，就不再对右边求值。\n\n&amp;&amp;：如果左边是 false，则右边不会求值\n||：如果左边是 true，则右边不会求值\n\n为数不多的能确定运算对象求值顺序的运算符之一\n\n优先级表（部分）\n后置递增，后置递减\n前置递增，前置递减，位求反，逻辑非，一元正负，解引用，取地址\n乘除模 $&gt;$ 加减\n左移右移\n小于，小于等于，大于，大于等于 $&gt;$ 相等，不相等\n位与 $&gt;$ 位异或 $&gt;$ 位或\n逻辑与 $&gt;$ 逻辑或\n条件 $&gt;$ 赋值 $&gt;$ 复合赋值\n\n\n优先级 (precedence)如果没记住：\n\n对于位运算符、逻辑运算符和其它运算符混合的情况，建议加括号\n(a + b) &gt;&gt; 1 和 a + b &gt;&gt; 1 是一样的，但前者看起来更让人安心\nif (a1 &lt; a2 || (a1 == a2 &amp;&amp; b1 &lt; b2))：内层的括号其实不需要加，但加上更清楚。\n\n\n其它情况，建议先翻运算符优先级表加强记忆，而不是滥用括号糊弄过去\n滥用括号会让你的代码一团糟\nif (((a1) &lt; (a2)) || (((a1) == (a2)) &amp;&amp; ((b1) &lt; (b2))))你能一眼看出这是 if (A || (B &amp;&amp; C)) 还是 if ((A || B) &amp;&amp; C) 吗？\n\n\n\n\n结合性 (associativity)形如 expr1 op1 expr2 op2 expr3 ... 的表达式，如果 op1 和 op2 具有相同的优先级，这时 op1 和 op2 的结合性决定了这个表达式被如何解析。\n\na - b + c 是 (a - b) + c 而非 a - (b + c)，因为 + 和 - 是左结合的。\n优先级相同的运算符一定具有相同的结合性。\n结合性无法决定求值顺序：f() - g() + h() 中的 f()，g() 和 h() 的调用顺序是 unspecified 的。\n\n\n求值顺序 (order of evaluation)\n结合性无法决定求值顺序：f() - g() + h() 中的 f()，g() 和 h() 的调用顺序是 unspecified 的。\n优先级无法决定求值顺序：f() + g() * h() 中的 f()，g() 和 h() 的调用顺序是 unspecified 的。\n\n\n求值顺序 (order of evaluation)仅有个别运算符规定了求值顺序，目前已知的有：\n\n&amp;&amp; 和 ||：短路求值\n?:\n\n典型的错误：\n\nadd_edge(read(), read(), read());本人亲身经历\nprintf(&quot;%d, %d&quot;, ++i, i);前年 CS100 的 quiz 题，当天中午 piazza 上就开团了\n\n\n求值顺序 (order of evaluation)看看标准怎么讲述这些东西：https://en.cppreference.com/w/c/language/eval_order\n\nvalue computation 和 side effects\nsequenced-before, unsequenced, indeterminably-sequenced\nrules\nundefined behavior\n\n\n控制流\nif-else练习：定义一个函数 abs_int，接受一个整数，返回其绝对值。输入一个整数，调用 abs_int，输出其绝对值。\n\n练习：定义一个函数 abs_int，接受一个整数，返回其绝对值。输入一个整数，调用 abs_int，输出其绝对值。\n\n  \n\n#include &lt;stdio.h&gt;\n\nint abs_int(int x) &#123;\n  if (x &lt; 0) &#123;\n    return -x;\n  &#125; else if (x == 0) &#123;\n    return 0;\n  &#125; else if (x &gt; 0) &#123;\n    return x;\n  &#125;\n&#125;\n  \n  \n\nint main(void) &#123;\n  int x;\n  scanf(&quot;%d&quot;, &amp;x);\n  printf(&quot;%d\\n&quot;, abs_int(x));\n  return 0;\n&#125;\n  \n\n\n\nif-else如果只有一条语句，就可以不打花括号：\nint abs_int(int x) &#123;\n  if (x &lt; 0)\n    return -x;\n  else if (x == 0)\n    return 0;\n  else if (x &gt; 0)\n    return x;\n&#125;\n\n\nif-elseint abs_int(int x) &#123;\n  if (x &lt; 0)\n    return -x;\n  else if (x == 0)\n    return 0;\n  else if (x &gt; 0)\n    return x;\n&#125;\n\n编译一下，有 warning？\n\n\n\n\n\n\n\n\n\nwarning: control reaches end of non-void function [-Wreturn-type]\n什么意思？\n\nif-elseint abs_int(int x) &#123;\n  if (x &lt; 0)\n    return -x;\n  else if (x == 0)\n    return 0;\n  else\n    return x;\n&#125;\n\n学会正确使用 else，不要反复 if 一个条件的正反面。\n\nif-elseint abs_int(int x) &#123;\n  if (x &lt; 0)\n    return -x;\n  else if (x == 0)\n    return 0;\n  else\n    return x;\n&#125;\n\n能不能更简洁？\n\nif-elseint abs_int(int x) &#123;\n  if (x &lt; 0)\n    return -x;\n  else\n    return x;\n&#125;\n\n最简洁：\nint abs_int(int x) &#123;\n  return x &lt; 0 ? -x : x;\n&#125;\n\n简洁即美德\n\nif-else写完代码之后再看一看，能不能简化？\nint max_verbose(int a, int b) &#123;\n  int result;\n  if (a &lt; b)\n  &#123;\n    result = b;\n  &#125;\n  else\n  &#123;\n    result = a;\n  &#125;\n  return result;\n&#125;\n\nint max_simpified(int a, int b) &#123;\n  return a &lt; b ? b : a;\n&#125;\n\n\nif-elseDangling else: 缩进会欺骗你\nif (condition1)\n  if (condition2)\n    printf(&quot;hello\\n&quot;);\nelse\n  printf(&quot;world\\n&quot;);\n\n格式化器 (formatter) 会告诉你真相\n\nwhilewhile (condition)\n  loop_body\n\n类似于 if-else，loop_body 可以是一条语句或**一个块 (block)**。\n练习：输入一个正整数 n，接下来输入 n 个整数，输出它们的和。\n\nwhile练习：输入一个正整数 n，接下来输入 n 个整数，输出它们的和。\nint main(void) &#123;\n  int n, a, x;\n  scanf(&quot;%d&quot;, &amp;n);\n  a = 0;\n  while (n--) &#123;\n    scanf(&quot;%d&quot;, &amp;x);\n    a = a + x;\n  &#125;\n  printf(&quot;%d\\n&quot;, a);\n  return 0;\n&#125;\n\n\nwhilewhile (n--) &#123;\n  // loop-body\n&#125;\n\n循环体执行了几次？执行完毕后 n 的值是多少？\n\nwhilewhile (n--) &#123;\n  // loop-body\n&#125;\n\n循环体执行了 n 次。\n在 n == 0 时，n-- 让 n 变成 -1，但返回 0，这使得循环结束。\n\nwhile能不能改进一下？\nint main(void) &#123;\n  int n, a, x;\n  scanf(&quot;%d&quot;, &amp;n);\n  a = 0;\n  while (n--) &#123;\n    scanf(&quot;%d&quot;, &amp;x);\n    a = a + x;\n  &#125;\n  printf(&quot;%d\\n&quot;, a);\n  return 0;\n&#125;\n\n\n变量命名要有意义int main(void) &#123;\n  int n, sum, x;\n  scanf(&quot;%d&quot;, &amp;n);\n  sum = 0;\n  while (n--) &#123;\n    scanf(&quot;%d&quot;, &amp;x);\n    sum = sum + x;\n  &#125;\n  printf(&quot;%d\\n&quot;, sum);\n  return 0;\n&#125;\n\n\n变量在即将使用的时候再定义int main(void) &#123;\n  int n;\n  scanf(&quot;%d&quot;, &amp;n);\n  int sum;\n  sum = 0;\n  while (n--) &#123;\n    int x;\n    scanf(&quot;%d&quot;, &amp;x);\n    sum = sum + x;\n  &#125;\n  printf(&quot;%d\\n&quot;, sum);\n  return 0;\n&#125;\n\n\n定义时立刻初始化，而非先定义再赋值int main(void) &#123;\n  int n;\n  scanf(&quot;%d&quot;, &amp;n);\n  int sum = 0;\n  while (n--) &#123;\n    int x;\n    scanf(&quot;%d&quot;, &amp;x);\n    sum = sum + x;\n  &#125;\n  printf(&quot;%d\\n&quot;, sum);\n  return 0;\n&#125;\n\n\n使用复合赋值运算符int main(void) &#123;\n  int n;\n  scanf(&quot;%d&quot;, &amp;n);\n  int sum = 0;\n  while (n--) &#123;\n    int x;\n    scanf(&quot;%d&quot;, &amp;x);\n    sum += x;\n  &#125;\n  printf(&quot;%d\\n&quot;, sum);\n  return 0;\n&#125;\n\n\nbreak如果遇到 0，则输出 hello world 并结束循环\nwhile (n--) &#123;\n  int x;\n  scanf(&quot;%d&quot;, &amp;x);\n  if (x == 0) &#123;\n    printf(&quot;Hello world\\n&quot;);\n    break;\n  &#125;\n  sum += x;\n&#125;\n\n\ncontinue跳过负数\nwhile (n--) &#123;\n  int x;\n  scanf(&quot;%d&quot;, &amp;x);\n  if (x &lt; 0)\n    continue;\n  if (x == 0) &#123;\n    printf(&quot;Hello world\\n&quot;);\n    break;\n  &#125;\n  sum += x;\n&#125;\n\n\nfor用 for 改写这个循环：\n\n  \n\nwhile (n--) &#123;\n  int x;\n  scanf(&quot;%d&quot;, &amp;x);\n  sum += x;\n&#125;\n  \n  \n\nfor (int i = 0; i &lt; n; ++i) &#123;\n  int x;\n  scanf(&quot;%d&quot;, &amp;x);\n  sum += x;\n&#125;\n  \n\n\n\nforfor (init_expression; condition; expression)\n  loop_body\n\n等价于\n&#123;\n  init_expression;\n  while (condition) &#123;\n    loop_body\n    expression;\n  &#125;\n&#125;\n\n\nforfor (init_expression; condition; expression)\n  loop_body\n\n\ninit_expression 可以是一个普通的表达式，也可以定义一种类型的若干个变量。\n\ncondition 和 expression 也可以更复杂。\nfor (int i = 0, j = n - 1; i &lt; j &amp;&amp; f(i, j); ++i, --j)\ninit_expression、condition、expression 都可以不写，其中 condition 如果不写，相当于 true。\n\nloop_body 是一条语句或者一个块。\n\n\n\n逗号运算符for (int i = 0, j = n - 1; i &lt; j &amp;&amp; f(i, j); ++i, --j)\n\n++i, --j 中的 , 是逗号运算符：\n\n先对左边求值，再对右边求值，返回右边的值。\ni = (f(), g()); 对 i 赋的值是 g() 的值，并且 f() 在 g() 之前调用。\n逗号运算符具有最低的优先级。\n为数不多的能确定运算对象求值顺序的运算符之一\nint i = 0, j = n - 1 和 f(i, j) 中的逗号不是逗号运算符！前者是声明语句而非表达式的一部分，后者是函数调用语法的一部分。\n\n\ndo-while一种我从来不用的循环语句\ndo\n  loop_body\nwhile (condition);\n\n\n先执行 loop_body，再根据 condition 判断是否进入下一次循环。\ncondition 不属于 loop_body 内部，在 loop_body 里定义的变量无法在 condition 里使用。\n\n\ndo-whiledo\n  loop_body\nwhile (condition);\n\n等价于\n\n  \n\nwhile (true) &#123;\n  &#123; loop_body &#125;\n  if (!condition)\n    break;\n&#125;\n  \n  \n\n&#123; loop_body &#125;\nfor (; condition; ) &#123;\n  &#123; loop_body &#125;\n&#125;\n  \n\n\n\n循环\ncfor (int i = 0; i &lt; n; ++i)\n&lt;!--code￼42--&gt;\n`int` 换成 `unsigned` 也可以，反正 `i` 不会取负值。\ncfor (int i = n - 1; i &gt;= 0; --i)\n&lt;!--code￼43--&gt;\n`int` 换成 `unsigned` 也可以，反正 `i` 不会取负值。\ncfor (unsigned i = n - 1; i &gt;= 0; --i)\n&lt;!--code￼44--&gt;\n&lt;/div&gt;\n&lt;div&gt;\n\n请改为：\nint main(void) &#123;\n  /* ... */\n  for (int i = 0; i &lt; n; ++i)\n    for (int j = 0; j &lt; n; ++j)\n      /* ... */\n&#125;\n  \n\n\n语言之所以这样发展，就是因为大量事实和经验表明这样更好。\n\n更清晰，也更不容易出错。\n\n\n变量命名、声明、初始化\n命名\n下划线命名：num_of_students, input_iterator\n驼峰命名：numOfStudents, inputIterator\n（在一个作用域内）不要同时存在非常类似的名字，例如 num, Num, num1\n例如 is_floating_point、floating_point、is_floating_point_v \n\n\n在一份代码中采用一种统一的命名方式，不要同时存在 num_of_students 和 numOfStudents\n宏通常全部大写：#define INT_MAX 2147483647\n我的习惯：变量、函数名均以小写开头，类名以大写开头\n\n\n变量的声明 (declaration) 和初始化 (initialization)目前我们见到的所有情况，声明和定义 (definition) 是一回事。\n在声明变量的同时可以进行初始化，这称为显式 (explicit) 初始化。\n\ncint i = 42;\n&lt;!--code￼46--&gt;\n是先定义（不初始化）再**赋值**。这两者在 C++ 中将有非常明显 &amp;&amp; 重要的区别。\n\n\n变量的声明 (declaration) 和初始化 (initialization)Best practice:\n\n在即将使用这个变量的时候再定义它，而不是将变量集中定义在块&#x2F;函数的开头\n借用 Scott Meyers 的一句话：”It reeks of a bygone millennium.”\n在 for 语句的 init_expression 里定义循环变量，而不是定义在外部。\n\n\n如果可以，在定义时就初始化这个变量，而非先默认初始化再赋值。\n某些场合是例外，比如\nint n;\nscanf(&quot;%d&quot;, &amp;n);\n\n\n\n\n如果没有显式地初始化…\n空初始化 (empty-initialization)：各种零，例如 int 的 0、double 的 0.0、char 的 &#39;\\0&#39;（ASCII 值为 0）、bool 的 false、指针的 NULL &#x2F; nullptr (since C23)\n对于全局 (global) 或者局部静态 (local static) 变量，不显式初始化的情况下执行空初始化。\n对于局部非静态 (local non-static) 变量，不显式初始化的情况下将持有未定义的值：你不能对它的值作任何假定，使用未定义的值的行为是未定义的行为。\n\n\n\n\n\n\n\n\n\n\n什么是静态？可以暂时忽略，以后学到了再说。\n\n避免使用未初始化的值未初始化的变量会拥有任何可能的值？\nint random(void) &#123;\n  int x;\n  return x;\n&#125;\n\n\n避免使用未初始化的值int random(void) &#123;\n  int x;\n  return x;\n&#125;\n\n这段代码可以直接被编译为 (x86-64 clang 15.0.0 -O2)\nrandom:\n        ret\n\n但有些编译器把它编译为 (RISC-V rv64gc gcc 12.2.0 -O2)\nrandom:\n        li a0, 0\n        ret\n\n\n避免使用未初始化的值编译器可以假定你的代码没有未定义的行为，因此对于未定义的行为可以任意处置，并不仅仅是使用一个随机的值这么简单。\n一些例子\n\n名字查找 (name lookup)\n作用域 (scope)\n  \n\nint add(int x, int y) &#123;\n  return x + y;\n&#125;\nint square(int x) &#123;\n  return x * x;\n&#125;\nint main(void) &#123;\n  int x; scanf(&quot;%d&quot;, &amp;x);\n  printf(&quot;%d\\n&quot;, square(x));\n  if (x == 42) &#123;\n    int x = 35;\n    printf(&quot;%d\\n&quot;, square(square(x)));\n  &#125;\n  for (int x = 1; x &lt;= 10; ++x)\n    printf(&quot;%d\\n&quot;, square(x + 1));\n  return 0;\n&#125;\n  \n  \n\n\n作用域呈现一个树结构：\ntxtglobal---add\n       |-square\n       |-main---if\n              |-for\n  &lt;/div&gt;\n&lt;/div&gt;\n\n---\n\n## 名字查找 (name lookup)\n\n&lt;div style=&quot;display: grid; grid-template-columns: 1fr 1fr;&quot;&gt;\n  &lt;div&gt;\n\n![](img/scopes.png)\n  &lt;/div&gt;\n  &lt;div&gt;\n\n- 作用域呈现一个**树结构**：\n- ```\n  global---add\n         |-square\n         |-main---if\n                |-for\n当名字 x 被引用时，对 x 的名字查找过程如下：\n首先将程序在这个位置一分为二，只能看见上方的名字\n从当前位置所在的作用域开始逐层往外找，找到的第一个 x 就是。\n\n\n\n\n\n作用域和名字查找\n  \n\n    \n\n作用域呈现一个树结构：\ntxtglobal---add\n       |-square\n       |-main---if\n              |-for\n- 内层作用域里定义的名字会掩盖外层相同的名字\n- 如果在一个作用域里定义了两个相同的名字，则是语法错误。\n  &lt;/div&gt;\n&lt;/div&gt;\n\n---\n\n## 作用域和名字查找\n\n- 坚持在“即将使用的时候”定义一个变量，将它的作用域限定在最小的范围中。\n- 无需刻意避开其它作用域中的同名变量。\n  \n  ```c\n  for (int i = 0; i &lt; n; ++i)\n    do_something(i);\n  for (int i = 0; i &lt; n; ++i)\n    do_another_thing(i);\n  if (condition()) &#123;\n    for (int i = 0; i &lt; n; ++i)\n      do_something_else(i);\n  &#125;\n\n","slug":"My-First-Blog","date":"2024-03-11T13:26:08.057Z","categories_index":"","tags_index":"","author_index":"HangxingZhang"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-03-04T12:58:00.482Z","categories_index":"","tags_index":"","author_index":"HangxingZhang"}]